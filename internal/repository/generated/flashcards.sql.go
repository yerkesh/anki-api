// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: flashcards.sql

package generated

import (
	"context"
)

const deleteFlashcardSoft = `-- name: DeleteFlashcardSoft :exec
UPDATE flashcards SET is_deleted = TRUE WHERE id = $1
`

func (q *Queries) DeleteFlashcardSoft(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteFlashcardSoft, id)
	return err
}

const insertAntonyms = `-- name: InsertAntonyms :exec
INSERT INTO antonyms (collection_id, flashcard_id, word, translated)
SELECT unnest($1::integer[]),
       unnest($2::integer[]),
       unnest($3::text[]),
       unnest($4::text[])
`

type InsertAntonymsParams struct {
	CollectionIds []int32  `db:"collection_ids" json:"collection_ids"`
	FlashcardIds  []int32  `db:"flashcard_ids" json:"flashcard_ids"`
	Word          []string `db:"word" json:"word"`
	Translated    []string `db:"translated" json:"translated"`
}

func (q *Queries) InsertAntonyms(ctx context.Context, arg InsertAntonymsParams) error {
	_, err := q.db.Exec(ctx, insertAntonyms,
		arg.CollectionIds,
		arg.FlashcardIds,
		arg.Word,
		arg.Translated,
	)
	return err
}

const insertFlashcard = `-- name: InsertFlashcard :one
INSERT INTO flashcards (collection_id, frontside, review_status, description, translated, part_of_speech, plural_noun, singular_noun, base_verb, past_verb, participle_verb)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11) RETURNING id
`

type InsertFlashcardParams struct {
	CollectionID   int32  `db:"collection_id" json:"collection_id"`
	Frontside      string `db:"frontside" json:"frontside"`
	ReviewStatus   string `db:"review_status" json:"review_status"`
	Description    string `db:"description" json:"description"`
	Translated     string `db:"translated" json:"translated"`
	PartOfSpeech   string `db:"part_of_speech" json:"part_of_speech"`
	PluralNoun     string `db:"plural_noun" json:"plural_noun"`
	SingularNoun   string `db:"singular_noun" json:"singular_noun"`
	BaseVerb       string `db:"base_verb" json:"base_verb"`
	PastVerb       string `db:"past_verb" json:"past_verb"`
	ParticipleVerb string `db:"participle_verb" json:"participle_verb"`
}

func (q *Queries) InsertFlashcard(ctx context.Context, arg InsertFlashcardParams) (int32, error) {
	row := q.db.QueryRow(ctx, insertFlashcard,
		arg.CollectionID,
		arg.Frontside,
		arg.ReviewStatus,
		arg.Description,
		arg.Translated,
		arg.PartOfSpeech,
		arg.PluralNoun,
		arg.SingularNoun,
		arg.BaseVerb,
		arg.PastVerb,
		arg.ParticipleVerb,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const insertMeanings = `-- name: InsertMeanings :exec
INSERT INTO meanings (collection_id, flashcard_id, meaning, example)
SELECT unnest($1::integer[]),
       unnest($2::integer[]),
       unnest($3::text[]),
       unnest($4::text[])
`

type InsertMeaningsParams struct {
	CollectionIds []int32  `db:"collection_ids" json:"collection_ids"`
	FlashcardIds  []int32  `db:"flashcard_ids" json:"flashcard_ids"`
	Meanings      []string `db:"meanings" json:"meanings"`
	Examples      []string `db:"examples" json:"examples"`
}

func (q *Queries) InsertMeanings(ctx context.Context, arg InsertMeaningsParams) error {
	_, err := q.db.Exec(ctx, insertMeanings,
		arg.CollectionIds,
		arg.FlashcardIds,
		arg.Meanings,
		arg.Examples,
	)
	return err
}

const insertSynonyms = `-- name: InsertSynonyms :exec
INSERT INTO synonyms (collection_id, flashcard_id, word, translated)
SELECT unnest($1::integer[]),
       unnest($2::integer[]),
       unnest($3::text[]),
       unnest($4::text[])
`

type InsertSynonymsParams struct {
	CollectionIds []int32  `db:"collection_ids" json:"collection_ids"`
	FlashcardIds  []int32  `db:"flashcard_ids" json:"flashcard_ids"`
	Word          []string `db:"word" json:"word"`
	Translated    []string `db:"translated" json:"translated"`
}

func (q *Queries) InsertSynonyms(ctx context.Context, arg InsertSynonymsParams) error {
	_, err := q.db.Exec(ctx, insertSynonyms,
		arg.CollectionIds,
		arg.FlashcardIds,
		arg.Word,
		arg.Translated,
	)
	return err
}

const selectAntonyms = `-- name: SelectAntonyms :many
SELECT flashcard_id, word, translated FROM antonyms
WHERE collection_id = $1
`

type SelectAntonymsRow struct {
	FlashcardID int32  `db:"flashcard_id" json:"flashcard_id"`
	Word        string `db:"word" json:"word"`
	Translated  string `db:"translated" json:"translated"`
}

func (q *Queries) SelectAntonyms(ctx context.Context, collectionID int32) ([]SelectAntonymsRow, error) {
	rows, err := q.db.Query(ctx, selectAntonyms, collectionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SelectAntonymsRow{}
	for rows.Next() {
		var i SelectAntonymsRow
		if err := rows.Scan(&i.FlashcardID, &i.Word, &i.Translated); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectAntonymsByCard = `-- name: SelectAntonymsByCard :many
SELECT flashcard_id, word, translated FROM antonyms
WHERE flashcard_id = $1
`

type SelectAntonymsByCardRow struct {
	FlashcardID int32  `db:"flashcard_id" json:"flashcard_id"`
	Word        string `db:"word" json:"word"`
	Translated  string `db:"translated" json:"translated"`
}

func (q *Queries) SelectAntonymsByCard(ctx context.Context, flashcardID int32) ([]SelectAntonymsByCardRow, error) {
	rows, err := q.db.Query(ctx, selectAntonymsByCard, flashcardID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SelectAntonymsByCardRow{}
	for rows.Next() {
		var i SelectAntonymsByCardRow
		if err := rows.Scan(&i.FlashcardID, &i.Word, &i.Translated); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectFlashcard = `-- name: SelectFlashcard :one
SELECT
    f.id,
    f.collection_id,
    f.frontside,
    f.review_status,
    f.description,
    f.translated,
    f.part_of_speech,
    f.plural_noun,
    f.singular_noun,
    f.base_verb,
    f.past_verb,
    f.participle_verb
FROM flashcards f
WHERE f.id = $1
`

type SelectFlashcardRow struct {
	ID             int32  `db:"id" json:"id"`
	CollectionID   int32  `db:"collection_id" json:"collection_id"`
	Frontside      string `db:"frontside" json:"frontside"`
	ReviewStatus   string `db:"review_status" json:"review_status"`
	Description    string `db:"description" json:"description"`
	Translated     string `db:"translated" json:"translated"`
	PartOfSpeech   string `db:"part_of_speech" json:"part_of_speech"`
	PluralNoun     string `db:"plural_noun" json:"plural_noun"`
	SingularNoun   string `db:"singular_noun" json:"singular_noun"`
	BaseVerb       string `db:"base_verb" json:"base_verb"`
	PastVerb       string `db:"past_verb" json:"past_verb"`
	ParticipleVerb string `db:"participle_verb" json:"participle_verb"`
}

func (q *Queries) SelectFlashcard(ctx context.Context, id int32) (SelectFlashcardRow, error) {
	row := q.db.QueryRow(ctx, selectFlashcard, id)
	var i SelectFlashcardRow
	err := row.Scan(
		&i.ID,
		&i.CollectionID,
		&i.Frontside,
		&i.ReviewStatus,
		&i.Description,
		&i.Translated,
		&i.PartOfSpeech,
		&i.PluralNoun,
		&i.SingularNoun,
		&i.BaseVerb,
		&i.PastVerb,
		&i.ParticipleVerb,
	)
	return i, err
}

const selectFlashcards = `-- name: SelectFlashcards :many
SELECT
    f.id,
    f.collection_id,
    f.frontside,
    f.review_status,
    f.description,
    f.translated,
    f.part_of_speech,
    f.plural_noun,
    f.singular_noun,
    f.base_verb,
    f.past_verb,
    f.participle_verb
FROM flashcards f
WHERE collection_id = $1 AND is_deleted = FALSE
ORDER BY
    CASE f.review_status
        WHEN 'repeat' THEN 1
        WHEN 'hard'   THEN 2
        WHEN 'easy'   THEN 3
        ELSE 4
        END,
    f.repeated_at
    LIMIT $2
OFFSET $3
`

type SelectFlashcardsParams struct {
	CollectionID int32 `db:"collection_id" json:"collection_id"`
	Limit        int32 `db:"limit" json:"limit"`
	Offset       int32 `db:"offset" json:"offset"`
}

type SelectFlashcardsRow struct {
	ID             int32  `db:"id" json:"id"`
	CollectionID   int32  `db:"collection_id" json:"collection_id"`
	Frontside      string `db:"frontside" json:"frontside"`
	ReviewStatus   string `db:"review_status" json:"review_status"`
	Description    string `db:"description" json:"description"`
	Translated     string `db:"translated" json:"translated"`
	PartOfSpeech   string `db:"part_of_speech" json:"part_of_speech"`
	PluralNoun     string `db:"plural_noun" json:"plural_noun"`
	SingularNoun   string `db:"singular_noun" json:"singular_noun"`
	BaseVerb       string `db:"base_verb" json:"base_verb"`
	PastVerb       string `db:"past_verb" json:"past_verb"`
	ParticipleVerb string `db:"participle_verb" json:"participle_verb"`
}

func (q *Queries) SelectFlashcards(ctx context.Context, arg SelectFlashcardsParams) ([]SelectFlashcardsRow, error) {
	rows, err := q.db.Query(ctx, selectFlashcards, arg.CollectionID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SelectFlashcardsRow{}
	for rows.Next() {
		var i SelectFlashcardsRow
		if err := rows.Scan(
			&i.ID,
			&i.CollectionID,
			&i.Frontside,
			&i.ReviewStatus,
			&i.Description,
			&i.Translated,
			&i.PartOfSpeech,
			&i.PluralNoun,
			&i.SingularNoun,
			&i.BaseVerb,
			&i.PastVerb,
			&i.ParticipleVerb,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectFlashcardsTotal = `-- name: SelectFlashcardsTotal :one
SELECT COUNT(*) FROM flashcards WHERE collection_id = $1 AND is_deleted = FALSE
`

func (q *Queries) SelectFlashcardsTotal(ctx context.Context, collectionID int32) (int64, error) {
	row := q.db.QueryRow(ctx, selectFlashcardsTotal, collectionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const selectMeanings = `-- name: SelectMeanings :many
SELECT flashcard_id, meaning, example FROM meanings
WHERE collection_id = $1
`

type SelectMeaningsRow struct {
	FlashcardID int32  `db:"flashcard_id" json:"flashcard_id"`
	Meaning     string `db:"meaning" json:"meaning"`
	Example     string `db:"example" json:"example"`
}

func (q *Queries) SelectMeanings(ctx context.Context, collectionID int32) ([]SelectMeaningsRow, error) {
	rows, err := q.db.Query(ctx, selectMeanings, collectionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SelectMeaningsRow{}
	for rows.Next() {
		var i SelectMeaningsRow
		if err := rows.Scan(&i.FlashcardID, &i.Meaning, &i.Example); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectMeaningsByCard = `-- name: SelectMeaningsByCard :many
SELECT flashcard_id, meaning, example FROM meanings
WHERE flashcard_id = $1
`

type SelectMeaningsByCardRow struct {
	FlashcardID int32  `db:"flashcard_id" json:"flashcard_id"`
	Meaning     string `db:"meaning" json:"meaning"`
	Example     string `db:"example" json:"example"`
}

func (q *Queries) SelectMeaningsByCard(ctx context.Context, flashcardID int32) ([]SelectMeaningsByCardRow, error) {
	rows, err := q.db.Query(ctx, selectMeaningsByCard, flashcardID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SelectMeaningsByCardRow{}
	for rows.Next() {
		var i SelectMeaningsByCardRow
		if err := rows.Scan(&i.FlashcardID, &i.Meaning, &i.Example); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectSynonyms = `-- name: SelectSynonyms :many
SELECT flashcard_id, word, translated FROM synonyms
WHERE collection_id = $1
`

type SelectSynonymsRow struct {
	FlashcardID int32  `db:"flashcard_id" json:"flashcard_id"`
	Word        string `db:"word" json:"word"`
	Translated  string `db:"translated" json:"translated"`
}

func (q *Queries) SelectSynonyms(ctx context.Context, collectionID int32) ([]SelectSynonymsRow, error) {
	rows, err := q.db.Query(ctx, selectSynonyms, collectionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SelectSynonymsRow{}
	for rows.Next() {
		var i SelectSynonymsRow
		if err := rows.Scan(&i.FlashcardID, &i.Word, &i.Translated); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const selectSynonymsByCard = `-- name: SelectSynonymsByCard :many
SELECT flashcard_id, word, translated FROM synonyms
WHERE flashcard_id = $1
`

type SelectSynonymsByCardRow struct {
	FlashcardID int32  `db:"flashcard_id" json:"flashcard_id"`
	Word        string `db:"word" json:"word"`
	Translated  string `db:"translated" json:"translated"`
}

func (q *Queries) SelectSynonymsByCard(ctx context.Context, flashcardID int32) ([]SelectSynonymsByCardRow, error) {
	rows, err := q.db.Query(ctx, selectSynonymsByCard, flashcardID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []SelectSynonymsByCardRow{}
	for rows.Next() {
		var i SelectSynonymsByCardRow
		if err := rows.Scan(&i.FlashcardID, &i.Word, &i.Translated); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFlashcardStatus = `-- name: UpdateFlashcardStatus :exec
UPDATE flashcards SET review_status = $1, repeated_at = now() WHERE id = $2
`

type UpdateFlashcardStatusParams struct {
	ReviewStatus string `db:"review_status" json:"review_status"`
	ID           int32  `db:"id" json:"id"`
}

func (q *Queries) UpdateFlashcardStatus(ctx context.Context, arg UpdateFlashcardStatusParams) error {
	_, err := q.db.Exec(ctx, updateFlashcardStatus, arg.ReviewStatus, arg.ID)
	return err
}
